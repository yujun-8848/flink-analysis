1.什么是垃圾？
    没有任何引用指向的对象（循环引用）
2. how to find it ?
    引用计数和可达性分析
3.GC roots
  线程栈变量，静态变量，常量池，JNI指针
4.垃圾回收算法
  - 标记清除
     位置不连续 产生碎片
  - 拷贝算法
     没有碎片，浪费空间
  - 标记压缩
     没有碎片，效率低
5. JVM分代模型
  - 部分垃圾回收器使用的模型
  - 新生代+ 老年代+永久代（1.7）/元数据空间（1.8）Metaspace
    - 永久代 元数据 -Class
    - 永久代必须指定大小限制，元数据可以设置，也可以不设置，无上限（受限于物理内存）
    - 字符串常量1.7 -永久代  1.8 堆
  - 新生代 = Eden + 2个suvivor区
  1. YGC回收后（拷贝算法），大多数的对象被回收，活着的进入s0
  2. 再次YGC，活着的对象eden+s0 -> s1
  3.再次YGC，eden + s1 ->s0
  4.年龄足够，进去old区  (15 CMS 6)
  5.s区装不下-> old
  - 老年代
  1. 老年代满了full gc
6.GC Tuning(Generation)
  1.尽量减少FGC
  2. MinorGC = YGC
  3. MajorGC = FGC
7.常见的垃圾回收器
  - Serial 年轻代 串行回收
  - Parallel 年轻代 并行回收
  - ParNew 年轻代 配合CMS的并行回收
  - SerialOld
  - ParallelOld
  - ConcurrentMarkSweep sweep 老年代 并发的 垃圾回收和应用程序同时进行，降低STW的时间（200ms）
  - G1(10ms)
  - ZGC(1ms)
  - Shenandoah
  - Eplison
  1.8 默认垃圾回收器 ：PS + ParallelOld
8.栈是运行时的单位，堆是存储时的单位
  - 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器
  - JVM直接对Java栈的操作只有两个：
     - 每个方法执行，伴随着进栈（入栈、压栈）
     - 执行结束后的出栈工作
  - 对于栈来说不存在垃圾回收问题(GC,OOM)
9. Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的
  - 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。
  如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机会抛出StackOverflowError异常。
  - 如果JVM栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时
  没有足够的内存去创建对应的虚拟机栈，则JVM会抛出OutOfMemoryError异常。
10. 栈帧存储结构
  - 局部变量表
  - 操作数栈
  - 动态链接
  - 方法返回地址（存放调用该方法的pc寄存器的值）
  - 一些附加信息
11. 操作数栈
  - 主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间
12. 动态链接
  - 指向运行时常量池的方法引用
13. 逃逸分析（标量替换、栈上分配、锁消除）
  - 如何快速的判断是否发生了逃逸分析，看new的对象是否在方法未被调用。
  - 不逃逸则在栈中分配，没有GC
  - 逃逸分配在堆中，有GC
14. 所有对象实例都创建在堆上
15. 方法区看作是一块独立于java堆的内存空间
16. static final 修饰的变量在编译的时候，即在类加载阶段-（连接-准备阶段）时就被初始化了，而
    单独的使用static仅在初始化才被赋值。
17.常量池有什么
  - 数量值
  - 字符串值
  - 类引用
  - 字段引用
  - 方法引用
18.每个class文件的头4个字节称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的class文件。
  很多文件存储标准中都使用魔数来进行身份识别，比如图片  
19. 对于静态变量使用final修饰后，会在链接中的准备阶段进行显示赋值
20. 结论：
  1. 在链接阶段的准备环节赋值的情况：
    - 对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值通常是在链接阶段的准备环节进行。
    - 对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行
  2. 在初始化阶段<clinit>()中赋值的情况：
    - 排除上述在准备环节赋值的情况之外的情况。
  最终结论：使用static + final修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类型或者string的字面量赋值，都在链接阶段的准备环节进行。